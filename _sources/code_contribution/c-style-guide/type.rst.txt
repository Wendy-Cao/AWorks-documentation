变量、结构、类型
=================

变量初始化
----------------------------

不合理的初始化数据是产生编程错误的常见根源。不恰当的变量初始化所导致的一系列问题都源于变量的默认初始值与预期的不同。70%软件问题都源于内存错误，指针变量是错误的核心。

**要求**：
    
1. 尽量在定义变量的时候初始化。
2. 局部指针变量必须初始化。
3. 在使用全局变量时尽量进行有效范围检查，使用指针型全局变量必须进行有效性检查。
4. 尽量在靠近第一次使用变量的地方声明和定义变量。例如，全局变量可以定义在初始化该变量的文件中。
5. 尽量避免使用全局变量，如果只在一个函数内使用的全局变量，尽量使用 ``static`` 变量，如 :numref:`static_auto_example`  所示：

 .. code-block:: c                                               
    :caption: static 变量使用范例
    :name: static_auto_example
        
    int g_state = 0;    /* 状态变量 */

    void led_swap (void)
    {
        if (g_state == 0) {
            g_state =  1;
            led_on();
        } else {
            g_state =  0;
            led_off();
        }
    }

    /* 以上程序应该改为如下程序 */
    void led_swap (void)
    {
        static int  state = 0;

        if (state == 0) {
            state =  1;
            led_on();
        } else {
            state =  0;
            led_off();
        }
    }

6. 与第五条类似，如果某全局变量只在一个文件中使用，应定义为 ``static`` 变量。   


 .. attention:: 
     ``static`` 变量会导致函数不可重入，同时也限制了模块不能多实例，更推荐的做法是使用 OO 方法来设计模块，即使用结构体来封装变量。

 .. _my-reference-label:
 
变量命名
----------

为变量命名时最重要的考虑事项是，该名字要完全、准确地描述出该变量所代表的事物。这个名字应该便于阅读，容易记忆，不能产生歧义。变量名的长度，最佳的变量名长度应该在8到16个字符之间，当变量名太短时，需要花费大量的时间来判断变量的含义。单字符的变量只能用于循环变量或者数组下标。

**要求**：

全部使用小写字符，必要时可添加下划线。变量名最多由三部分组成：作用域、类型、描述。

1. 作用域：该变量的作用范围，确定该变量的有效范围是在函数体外还是函数体内。
2. 类型：该变量的类型，使用小写字符。只有指针（包括函数指针）类型变量需要在命名中使用类型。
3. 描述：要完全、准确地描述出该变量所代表的事物，例如： ``max`` 、 ``error`` 、 ``new`` 等等。


全局变量的定义
^^^^^^^^^^^^^^^

全局变量的命名以 ``g`` 开头，例如： ``g_max``。
如果使用指针类型，则在 ``g`` 后面加小写 ``p`` ，例如： ``gp_value`` 。
如果是函数指针类型，则在 ``g`` 后面加小写 ``pfn`` ，例如： ``gpfn_io_read`` 。
静态全局变量需要加上 ``__`` 前缀，例如， ``__g_max`` 、 ``__gp_value`` 、 ``__gpfn_io_read`` 。

变量类型后紧跟变量的描述，变量的描述使用小写加下划线，例如： ``name``\ 、\ 
``error_number`` 等等。

**要求**:

1. 禁止使用拼音作为变量的描述。
2. 变量名全部使用小写加下划线，不允许使用大小写混合方式。
3. 函数指针类型变量统一使用 ``pfn`` 类型缩写。
4. 为了避免模块与用户程序或其他模块产生命名冲突，模块内部使用的全局变量命名中还应加上特有的标识作为命名空间。

下面给出一些模块内部全局变量的定义范例。例如，我们提供给用户一个直流电机控制软件包，软件包内定义了一些全局变量供我们自己使用，同时为了防止与用户程序或其他模块产生命名冲突，我们在定义模块内全局变量时把 ``motor`` 作为命名空间，如 :numref:`local_global_def` 所示。

 .. code-block:: c                                               
    :caption: 模块内部全局变量定义
    :name: local_global_def
    
    int                    g_motor_max;                    /* 最大值 */

    static unsigned int  __g_motor_error_number;           /* 错误号 */
    static signed int    __g_motor_start_value = 0;        /* 起始数值 */

    static char          __g_motor_first;                  /* 第一个字符 */
    static char          __g_motor_name[] = "zlg mcu";     /* 名字字符串 */


**其他要求**：

1. 在连续定义多个全局变量的时候必须对齐。
2. 右边加入对每一个全局变量作用的行注释。
3. 不允许使用 ``TAB键`` 作缩进。（缩进单位为 4 个空格）
4. 在不同类型全局变量或不同含义的全局变量定义之间要加入空行。如下面的程序清单所
   示，在记录超时时间的三个变量和记录数据报个数的三个变量定义间加一个空行。
    
 .. code-block:: c                                               
    :caption: 变量定义中空行的使用范例
    :name: example_blank_line_in_var_def

    static unsigned long       __g_ip_default_timeout;  /* IP 数据报超时时间 */
    static unsigned long       __g_tcp_default_timeout; /* TCP 数据报超时时间 */
    static unsigned long       __g_udp_default_timeout; /* UDP 数据报超时时间 */

    static unsigned long       __g_ip_pack_counter;     /* IP 数据报计数器 */
    static unsigned long       __g_udp_pack_counter;    /* UDP 数据报计数器 */
    static unsigned long       __g_tcp_pack_counter;    /* TCP 数据报计数器 */

    
5. 所有程序中，注释必须使用封闭式注释： ``/* … */`` 。
6. 在变量后空至少1个空格开始行注释，行注释起始以相同类型变量中最靠右的为基准对齐
   ，行注释结束不必对齐，但行注释结束处不能超过第80列。
7. 行注释的第一个字符与 ``/*`` 符号间至少保留一个空格。
8. 变量类型必须写在一行的起始位置，除非含有 ``extern`` 关键字或者其他宏定义。


模块中指针型全局变量的定义与对齐，如 :numref:`example_static_global_var_align` 所示。

 .. code-block:: c
    :caption: 模块中指针型全局变量的定义与对齐范例：
    :name: example_static_global_var_align


    static int   __g_max;   /* 最大值 */  
    static int  *__gp_Max;  /* 最大值指针 */  
    static int **__gpp_max; /* 最大值双指针 */


**要求** ：

1. 对齐的基准是英文字符或下划线。
2. 指针变量的类型字符前缀 ``p`` 紧跟作用域字符 ``g`` 。
3. 指针变量标志 ``*`` 必须紧跟变量名。例外情况，如 :numref:`example_pointer_def_exeption` 所示。

 .. code-block:: c
    :caption: ``*`` 与变量名不贴近的例外情况范例
    :name: example_pointer_def_exeption
    
    int * const  ptr2;

4. 禁止使用三重以上的指针。

**要求**：

1. 变量有初始化时，赋值符号 ``=`` 左右必须使用空格。
2. 左端的空格的个数以上下对齐为准。
3. 在保证右端对齐的情况下，右端的空格数力求最少（不少于一个）。

指针型全局变量的定义，与非指针全局变量的对齐，如 :numref:`example_global_pointer_def` 所示。

 .. code-block:: c
    :caption: 指针型全局变量的定义与对齐范例
    :name: example_global_pointer_def

    int       g_max;    /**< 最大值 */
    int      *gp_max;   /**< 最大值指针 */
    int     **gpp_max;  /**< 最大值双指针 */

含有 ``extern`` 关键字或者其他宏定义的变量书写范例，如 :numref:`example_extern_macro_var_def` 所示。

 .. code-block:: c
    :caption: 含有 ``extern`` 关键字或者其他宏定义的变量书写范例
    :name: example_extern_macro_var_def
    
    #define EXT       extern

    extern int        g_max;    /**< 最大值 */
    extern int       *gp_max;   /**< 最大值指针 */
    extern int      **gpp_max;  /**< 最大值双指针 */

    EXT    int        g_mix;    /**< 最小值 */
    EXT    int       *gp_mix;   /**< 最小值指针 */
    EXT    int      **gpp_mix;  /**< 最小值双指针 */
    
**要求** ：

    1. ``extern`` 关键字或者其他宏定义必须写在一行的起始位置。
    2. ``extern`` 关键字或者其他宏定义后面至少加一个空格。
    3. 同类型或含义类似变量类型字段应该对齐。

局部变量的定义
^^^^^^^^^^^^^^^ 

局部变量的定义与全局变量基本相同，但是，局部变量前不加双下划线 ``__`` 和作用域字符。只包含指针类型和变量的描述。下面给出一些全局变量的定义范例。如 :numref:`example_local_var_def` 所示。

 .. code-block:: c
    :caption: 局部变量定义范例
    :name: example_local_var_def  

    int      sheep_number;          /* 绵羊的数量 */
    int     *p_car_number = NULL;   /* 指向车辆数目的指针 */

**要求** ：
    
1. 局部变量只包含指针变量类型和变量描述这两部分内容。
2. 定义局部指针型变量时，必须初始化为 ``NULL`` 或者一个有意义的地址，以减少发生错误的可能性。不允许出现悬空指针（指向无效地址的指针，俗称：野指针）。
3. 指针变量标志 ``*`` 必须紧跟变量名。
4. 变量名对齐时，指针符号应该向左移动，以英文字母或下划线作为起始对齐点。
5. 在不同类型局部变量或不同含义的局部变量定义之间要加入空行。
6. 函数的第一行代码与最后一个局部变量定义之间至少保留一个空行。当变量定义中使用空行时，第一行代码与最后一个局部变量定义之间保留两个空行，其它情况保留一个空行。
7. 静态局部变量命名以 ``s_`` 开头。
    
指针型变量定义，如 :numref:`example_pointer_local_var_def` 所示。

 .. code-block:: c
    :caption: 指针型局部变量定义范例
    :name: example_pointer_local_var_def

    char     *p_name        = NULL;     /* 名字指针 */
    int     **pp_car_number = NULL;     /* 指向汽车数量指针地址的指针 */
    
局部变量中的特例：循环变量与数组下标变量。循环变量与数组下标变量允许超越以上要求，允许使用单字符变量名。如 :numref:`example_local_circal_array_var_def` 所示。

 .. code-block:: c
    :caption: 局部循环变量与数组下标变量定义
    :name: example_local_circal_array_var_def
    
    int     i;  /* 循环变量 */
    short   s;  /* 数组下标 */

静态局部变量的定义如 :numref:`example_static_var_def` 所示

 .. code-block:: c
    :caption: 静态局部变量定义
    :name: example_static_var_def
    :emphasize-lines: 3
    
    int motor_init (void) 
    {
        static bool  s_inited = FALSE;  /* 模块已初始化标识 */
        
        int          counter  = 0;      /* 计数器 */


        if (s_inited == TRUE) {
            return -1;
        }
        s_inited = TRUE;
        ...
    }


结构变量与类型
--------------

模块内结构体命名与定义
^^^^^^^^^^^^^^^^^^^^^^

为了不污染用户命名空间，非应用程序（模块内部）使用的结构体与类型必须以双下划线开
始 ``__`` 。下面是一个非应用程序结构体定义范例，如 :numref:`example_module_struct_member_def` 所示。

 .. code-block:: c
    :caption: 模块内部结构体变量定义范例
    :name: example_module_struct_member_def
    
    struct __dlist {
        int                  value;         /* 节点的数值 */
        
        struct __dlist      *p_next;        /* 双链表前向指针 */
        struct __dlist      *p_prev;        /* 双链表后向指针 */
    };
    typedef struct __dlist   __dlist_t;     /* 定义类型 */

    /* 需要使用struct __dlist的结构体 */
    struct __my_app_struct {
        struct __dlist   dlist_node;        /* 链表节点 */
        struct __dlist  *p_dlist_head;      /* 链表头指针 */
        void           (*pfn_act)(void);    /* 动作函数指针 */
    };

如 :numref:`example_module_struct_member_def` 所示。结构体的名字应该能够准确描述出该变量所代表的事物，这里将双
链表定义为 ``__dlist`` ，清晰易懂。结构体变量名中间允许插入下划线。

组合关键字中间为一个空格，例如： ``unsigned char``  、 ``typedef struct`` 等等。
    
**要求** ：

1. ``struct`` 关键字必须写在一行的起始位置，一般在 ``struct`` 上部还有对该结构体全局
   性的描述，采用块注释结构。
2. ``struct`` 后只能加一个空格，然后键入结构体名。
3. 结构体名称必须为小写，非应用程序（模块内部）使用的结构体名字前，必须有双下划
   线 ``__`` 。
4. 结构体名字的后面加一个空格，然后键入 ``{`` 。
5. 结构体成员类型写在起始位置后四个空格处。
6. 一个结构体所有成员必须左对齐，以英文字母或下划线作为起始对齐点。
7. 在不同含义或不同类型的成员定义之间要加入空行。
8. 每个成员右边要跟有行注释。
9. 在最后一个成员的下一行起始位置写入： ``};`` 。
10. 不允许在结构体中使用位域。

如果程序中，需要使用类型来访问结构体，那么类型的定义必须紧跟结构体的定义，建议使
用结构体名后跟 ``_t`` 来命名结构体类型，如 ``__dlist_t`` 。

不建议定义结构体类型的指针类型，除非移植等确实需要。

应用程序内结构体命名与定义
^^^^^^^^^^^^^^^^^^^^^^^^^^^

在应用程序中定义的结构体前面不需要加入双下划线： ``__`` ，如 :numref:`example_app_struct_var_def` 所示。

 .. code-block:: c
    :caption: 应用程序结构体变量定义范例
    :name: example_app_struct_var_def
    
    struct dlist {
        int                  value;      /* 节点的数值 */
        
        struct dlist        *p_next;     /* 双链表前向指针 */
        struct dlist        *p_prev;     /* 双链表后向指针 */
    };
    typedef struct dlist     dlist_t;    /* 定义类型 */

    /* 需要使用struct dlist的结构体 */
    struct my_app_struct {
        struct dlist   dlist_node;       /* 链表节点 */
        struct dlist  *p_dlist_head;     /* 链表头指针 */
        void         (*pfn_act)(void);   /* 动作函数指针 */
    };

    /***************************************************************************
      双链表表头指针全局变量定义
    ***************************************************************************/
    dlist_t     *gp_dlist_header;       /* 表头指针 */

**要求**：

1. 当一个结构在程序中出现次数非常多，应该将此结构体定义为类型。
2. 对于编译器或CPU冲突的C类型，也可以写成结构，建议使用标准C已经定义的类型或结构，例如： ``uint8_t`` 、 ``uint32_t`` 等（在标准头文件 ``stdint.h`` 中）。
3. 严禁使用 ``#define`` 语句将C类型定义为宏。如 :numref:`example_define_def_macro_bad` 所示，就会出现严重错误。

 .. code-block:: c
    :caption:  #define语句定义的宏类型错误范例
    :name: example_define_def_macro_bad

    #define PINT        int*

    PINT    p_a, p_b, p_c;  /* 定义三个指针变量 */

以上代码只有 ``p_a`` 为指针变量，其余都为 ``int`` 型变量。

4. 如果定义的是结构体类型，类型名尽量与结构体名统一。

下面给出部分类型定义范例，如 :numref:`example_tyedef` 所示。（模块内部类型前面加双下划线 ``__`` ）

 .. code-block:: c
    :caption: 类型定义范例
    :name: example_tyedef

    typedef struct list           list_t;         
    typedef struct udp_header     udp_header_t;     
    typedef void                (*task_t)(void *); 


**数据变量的类型定义要求**：

1. ``typedef`` 关键字必须写在一行的起始处。
2. ``typedef`` 关键字后加一个空格，然后紧跟原始类型名。
3. 新定义的类型名要求左对齐，以英文字母或下划线作为起始对齐点。
4. 每个类型定义要有相关类型说明的行注释。
5. 当语句长度超过80个字符时，可以将行注释独立一行，放在上边。（语句后加上空行）
6. 类型名必须全部小写，且必须是两个字符以上，后跟 ``_t`` 结束。
7. 与结构体相同，类型名中间允许使用下划线。

**函数类型及函数指针类型定义附加要求**：

1. 函数或函数指针类型的类型名，与变量类型名要求对齐。以英文字母或下划线作为起始对齐点。
2. 函数的返回类型名要求与变量类型定义的原始类型名对齐。
3. 函数参数括号要紧贴函数类型名。


其他函数定义及声明标准，见后面章节。

    
