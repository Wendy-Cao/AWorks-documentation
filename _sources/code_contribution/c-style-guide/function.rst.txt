函数、函数名及其参数
=====================

函数
-----

函数是一个命名了的具有独立功能的程序段。所以，当我们要完成一个相对独立的功能，们就需要定义一个函数，但并不是在一个函数中实现所有功能。

函数的基本要求
^^^^^^^^^^^^^^^
  
**要求：**

1. 函数的规模必须限制在200行以内。过于复杂或冗长的函数不利于结构化程序设计，而且不利于调试与错误的排除。

2. 一个函数仅完成一件功能。不要将很多联系较少的功能写在同一个函数中。不要设计多用途面面俱到的函数。

3. 为简单功能编写函数。虽然为仅用一两行就可完成的功能去编函数似乎没有必要，但使用函数可使功能明确化，增加程序可读性，亦可方便维护、测试。 

4. 函数的功能应该是可以预测的，也就是只要输入数据相同就应产生可以预测的输出。 

5. 尽量不要编写依赖于其他函数内部实现的函数。 

6. 避免设计多参数函数，不使用的参数从接口中去掉。 

7. 非调度函数应减少或防止控制参数，尽量只使用数据参数。本建议目的是防止函数间的控制耦合。调度函数是指根据输入的消息类型或控制命令，来启动相应的功能实体即函数或过程），而本身并不完成具体功能。控制参数是指改变函数功能行为的参数，即函数要根据此参数来决定具体怎样工作。非调度函数的控制参数增加了函数间的控制耦合，很可能使函数间的耦合度增大，并使函数的功能不唯一。如 :numref:`example_reduce_control_arguments` 所示。

 .. code-block:: c
    :caption: 减少控制参数的范例
    :name: example_reduce_control_arguments

    /* 如下函数构造不太合理: */
    int int_add_and_sub (int opt, int num1, int num2)
    {
        if (opt == INTEGER_ADD) {
            return (num1 + num2);
        } else {
            return (num1 - num2);
        }
    }
   
    /* 应该改为: */
    int int_add (int num1, int num2)
    {
        return (num1 + num2);
    }
    int int_sub (int num1, int num2)
    {
        return (num1 - num2);
    }

8. 尽量检查函数所有参数输入的有效性。（有条件）

9. 检查函数所有非参数输入的有效性，如数据文件、公共变量等。

10. 让函数在调用点显得易懂、容易理解。

11. 避免函数中不必要语句，防止程序中的垃圾代码。

12. 函数中不必要的语句可以使用如下两种注释，如 :numref:`example_comment_on_invalid_code` 所示。

 .. code-block:: c
    :caption: 函数中无效代码的注释范例
    :name: example_comment_on_invalid_code
    
    #if 0
      ...
    #endif /* 0 */
    
    /* 调试信息可以使用如下方式：*/
    #ifdef __DEBUG
      ..
    #endif /* __DEBUG */

13. 防止把没有关联的语句放到一个函数中。防止函数或过程内出现随机内聚。随机内聚是指将没有关联或关联很弱的语句放到同一个函数或过程中。随机内聚给函数或过程的维护、测试及以后的升级等造成了不便，同时也使函数或过程的功能不明确。使用随机内聚函数，常常容易导致代码维护的问题，例如：在一种应用场合需要改进此函数，而另一种应用场合又不允许这种改进，从而陷入困境。在编程时，经常遇到在不同函数中使用相同的代码，许多开发人员都愿把这些代码提出来，并构成一个新函数。若这些代码关联较大并且是完成一个功能的，那么这种构造是合理的，否则这种构造将产生随机内聚的函数。如 :numref:`example_random_aggregation` 所示。

 .. code-block:: c
    :caption: 随机内聚函数改造范例
    :name: example_random_aggregation

    /* 下面的函数是一种随机内聚：*/
    void var_init (void)
    {
        g_rect_area.xsize = 100;
        g_rect_area.ysize = 100;

        g_men_child.weight  = 30;
        g_men_child.stature = 140;
    }
    /* 以上函数中，一个区域的属性与一个人的属性基本没有任何关系，故以上函数是随机内聚。
    应如下分为两个函数：*/
    void rect_init (void)
    {
        g_rect_area.xsize = 100;
        g_rect_area.ysize = 100;
    }
    void men_init (void)
    {
        g_men_child.weight  = 30;
        g_men_child.stature = 140;
    }

14. 如果多段代码重复做同一件事情，那么在函数的划分上可能存在问题。若此段代码各语句之间有实质性关联并且是完成同一件功能的，那么可考虑把此段代码构造成一个新的函数。

15. 功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在。模块中函数划分的过多，一般会使函数间的接口变得复杂。所以过“小”的函数，例如扇入很低的或功能不明确的函数，不值得单独存在。

16. 设计高扇入、合理扇出（小于7）的函数。扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。扇出过大，表明函数过分复杂，需要控制和协调过多的下级函数；而扇出过小，如总是1，表明函数的调用层次可能过多，这样不利程序阅读和函数结构的分析，并且程序运行时会对系统资源如堆栈空间等造成压力。函数较合理的扇出（调度函数除外）通常是3-5。扇出太大，一般是由于缺乏中间层次，可适当增加中间层次的函数。扇出太小，可把下级函数进一步分解多个函数，或合并到上级函数中。当然分解或合并函数时，不能改变要实现的功能，也不能违背函数间的独立性。扇入越大，表明使用此函数的上级函数越多，这样的函数使用效率高，但不能违背函数间的独立性而单纯地追求高扇入。公共模块中的函数及底层函数应该有较高的扇入。较良好的软件结构通常是顶层函数的扇出较高，中层函数的扇出较少，而底层函数则扇入到公共模块中。

17. 减少函数本身或函数间的递归调用。递归调用特别是函数间的递归调用（如A->B->C->A），影响程序的可理解性；递归调用一般都占用较多的系统资源（如栈空间）；递归调用对程序的测试有一定影响。故除非为某些算法或功能的实现方便，应减少没必要的递归调用。

18. 仔细分析模块的功能及性能需求，并进一步细分，同时若有必要画出有关数据流图，据此来进行模块的函数划分与组织。函数的划分与组织是模块的实现过程中很关键的步骤，如何划分出合理的函数结构，关系到模块的最终效率和可维护性、可测性等。根据模块的功能图或/及数据流图映射出函数结构是常用方法之一。

19. 改进模块中函数的结构，降低函数间的耦合度，并提高函数的独立性以及代码可读性、效率和可维护性。优化函数结构时，要遵守以下原则：
    
    1. 不能影响模块功能的实现。 
    2. 仔细考查模块或函数出错处理及模块的性能要求并进行完善。 
    3. 通过分解或合并函数来改进软件结构。
    4. 考查函数的规模，过大的要进行分解。
    5. 降低函数间接口的复杂度。
    6. 不同层次的函数调用要有较合理的扇入、扇出。
    7. 函数功能应可预测。
    8. 提高函数内聚。（单一功能的函数内聚最高）

 .. attention::
    对初步划分后的函数结构应进行改进、优化，使之更为合理。

20. 在多任务操作系统的环境下编程，要注意函数可重入性的构造。所有使用外设的代码都可能是不可重入的，需要使用各种方法避免重入。

21. 对于提供了返回值的函数，在引用时最好使用其返回值。如果不使用，尽量在调用时，加入： ``(void)`` 语句。如 :numref:`example_no_return` 所示。

 .. code-block:: c
    :caption: 不使用函数返回值的范例
    :name: example_no_return

    int net_send (...)
    {
        return 0;
    }
    /* 如果调用上面的 net_send 函数，但是不使用其返回值，尽量使用如下方式：*/
        (void)net_send(...);


22. 当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替或者使用局部变量。如 :numref:`example_replace_long_var_with_macro` 所示。

 .. code-block:: c
    :caption: 使用宏替换较长的变量范例
    :name: example_replace_long_var_with_macro

    #define __NETPORT_GET_IP(i)   __g_nd_buffer[i].netport.myip.s_addr

    int __ip_recv (int index, uint8_t *p_buffer)
    {
      uint32_t myip;
      ...
      myip = __NETPORT_GET_IP(index);   /* 获得指定网络接口的IP地址 */
      ...
    }

23. 编程的同时要为单元测试选择恰当的测试点，并仔细构造测试代码、测试用例，同时给出明确的注释说明。测试代码部分应作为（模块中的）一个子模块，以方便测试代码在模块中的安装与拆卸（通过调测开关）。如 :numref:`example_add_dbginfo_in_source` 所示。

 .. code-block:: c
    :caption: 代码中添加测试信息
    :name: example_add_dbginfo_in_source

    #ifdef  __DEBUG_LOG_EN
    #define __DEBUG_LOG(p_str)    uart_send_str(p_str)
    #else
    #define __DEBUG_LOG(p_str)
    #endif

    int mem_copy (void *p_dest_addr, void *p_src_addr, int count)
    {
        if (!p_dest_addr) {
          __DEBUG_LOG("p_dest_addr is NULL.\n");
          return -1;
        }
        if (!p_src_addr) {
          __DEBUG_LOG("p_src_addr is NULL.\n");
          return -1;
        }
        if (!count) {
          __DEBUG_LOG("count is 0.\n");
          return -1;
        }
        ...
    }

函数名及其参数
-------------------

函数命名规范
^^^^^^^^^^^^^

函数的命名采用“主+动”形式。此命名方式是很多大型软件采取的命名方式，例如：Linux、VxWorks、µC/OS-II等等。这种命名清晰易懂，产生歧义的可能性小。

最佳的函数名长度应该在8到16个字符之间。

**要求：**

1. 函数名以主语开始，这个部分一般说明函数操作的对象，即函数是为处理什么对象而编写的。例如： ``task`` 、 ``semaphore`` 、 ``motor`` 等等。

2. 函数名的第二部分是动词，一般描述对象的行为，即函数是为对象做什么服务的。例如： ``create`` 、 ``pend`` 、 ``on`` 、 ``off`` 等等。

函数的全名示例如下::

    task_create、semaphore_pend、motor_on、led_off

**要求：**

1. 函数名的主语部分为小写英文单词或英文单词缩写。
2. 动词部分全部为小写。
3. 主语部分、动词部分及主语动词的链接部分可使用下划线。
   为了不污染用户命名空间，非应用程序（模块内部）使用的函数必须以双下划线开始 ``__`` ，例如： ``__task_init`` 、 ``__semaphore_read`` 等等。
   如果出现名词众多（即对象继承层数过多的情况）可以使用多名词做函数起始主语，所有主语全部小写，主语之间加下划线。例如：EPC这个模块包含有WDT这个子模块，WDT这个模块的一个init操作的函数可以使用如下函数名： ``epc_wdt_init`` 。
4. 在AWorks平台中要求所有的函数和全局变量命名前加 ``aw_`` 前缀。

函数头缩进格式
^^^^^^^^^^^^^^^

当函数的返回值、函数名、参数不超过80个字符时写在同一行，如 :numref:`example_function_length_less_than_80` 所示。

 .. code-block:: c
    :caption: 80个字符以内的函数定义范例
    :name: example_function_length_less_than_80

    int motor_run (int speed, int direction)
    {
        ...
    }


**要求：**
  
1. 函数返回类型放在一行的起始点。
2. 函数名与函数返回类型同占一行。
3. 函数定义时，参数列表的左“(”与函数名最右边字符之间保留一个空格。
4. 函数参数排列不得超过80个字符，超过时使用纵向参数排列。
5. 逗号后面加空格，前面不允许加空格。
6. 参数类型后空两个空格在写入变量名。
7. 函数体的左右大括号放在最左边。
8. 返回类型与函数名之间留1到2个空格。

当一行80个字符写不下一个函数定义时使用纵向排列。如 :numref:`example_function_length_bigger_than_80` 所示。

 .. code-block:: c
    :caption: 80个字符以上的函数定义范例
    :name: example_function_length_bigger_than_80

    int  motor_run (int speed,
                    int direction,
                    int time)
    {
        ...
    }
    
    /* 当一行中第一个参数也写不下时使用下面的方式：*/
    static struct motor_control_struct * __motor_create (
        int speed, int direction)
    {
        ...
    }
    
    /* 当一行中第一个参数也写不下，且第二行也写不下所有参数时，使用纵向排列：*/
    static struct motor_control_struct * __motor_create (
        int speed,
        int direction,
        int timeout)
    {
        ...
    }
  
**要求：**
  
1. 参数间隔符 ``,`` 放在参数右侧。
2. 参数类型与参数名之间空格数不确定。
3. 参数类型纵向对齐第一个参数的类型。
4. 参数名纵向对齐。
5. 参数列表的右括号紧贴最后一个参数。


AWorks平台函数返回值规范
^^^^^^^^^^^^^^^^^^^^^^^^^

在AWorks平台中，如果函数的返回值表示的是错误类型，则返回值类型必须使用 ``aw_err_t`` ，执行不成功的返回值必须使用 ``aw_errno.h`` 中定义的错误码的负值（加 ``-`` 号），如 ``AW_EINVAL`` ，执行成功返回 ``AW_OK`` 。返回值类型为布尔、指针或数值等的除外，此外若函数要兼容已有的标准的除外。
AWorks平台函数返回值规范示例如 :numref:`example_return_val_of_aworks` 所示。

 .. code-block:: c
    :caption: AWorks平台函数返回值规范示例
    :name: example_return_val_of_aworks

    aw_err_t aw_event_raise (struct event_type *p_event,
                             void              *p_event_data,
                             int                proc_type)
    {
        if (NULL == p_event) {
            return -AW_EINVAL; /* 参数无效 */
        }
        ...
        return AW_OK;
    }






