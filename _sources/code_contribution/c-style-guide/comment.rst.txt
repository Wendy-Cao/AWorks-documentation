注释、注释对齐
===============

注释
---------

注释分为行注释和块注释，块注释又分为函数体内块注释与函数体外块注释。行注释主要是说明该行代码执行的功能，函数体内块注释主要数说明下面的语句块执行的功能，函数体外块注释主要说明类型、结构、宏定义以及函数声明、全局变量定义等等。

从注释是否带特殊格式从而可以被文档工具抓取来分注释可分为普通注释和特殊块注释。所有注释要求能使用Doxygen抓取，特殊块注释使用 ``/**`` 开始，代码行后使用 ``/**<`` 开始。

**要求：**

1. 一般情况下，源程序有效注释量必须在15％以上，一般要达到20%以上。注释的原则是有助于对程序的阅读理解，在该加的地方都加了，注释不宜太多也不能太少，注释语言必须准确、易懂、简洁。

2. 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。

3. 注释的内容要清楚、明了，含义准确，防止注释二义性。错误的注释不但无益反而有害。

4. 避免在注释中使用缩写，特别是非常规使用的缩写。在使用缩写时或之前，应对缩写进行必要的说明。

5. 全局变量要有较详细的注释，包括对其功能、及注意事项等的说明。

6. 对于 ``switch`` 语句下的 ``case`` 语句，如果因为特殊情况需要处理完一个 ``case`` 后进入下一个 ``case`` 处理，必须在该 ``case`` 语句处理完、下一个 ``case`` 语句前加上明确的注释。这样比较清楚程序编写者的意图，有效防止无故遗漏 ``break`` 语句。

7. 通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。

8. 在语句块的功能、意图层次上进行注释，提供有用、额外的信息。注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。

9. 所有的注释均采用C89的 ``/* ... */`` 封闭式注释。
10. 除固定文件头说明、文件结束注释和函数体内注释外全部使用特殊块注释。
11. 所有特殊注释块建议尽量加 ``\brief`` 指示。


注释对齐
---------

单行注释
^^^^^^^^^

单行注释（短注释）可单独占用一行，或写在定义或语句后共占一行，结束点不得超过80个字符处，若写不下则使用多行注释。

**要求：**

1. 独立的单行注释的起始点与该处代码的缩进一致。
2. 定义或语句后的单行注释在定义或语句后留至少一个空格后开始行注释。
3. 相似或功能相同的定义或语句的行注释开始处对齐。
4. 行注释的结束点不超过第80个字符处。
5. ``/*`` 和 ``*/`` 符号在一行以内。如 :numref:`example_single_line_comment` 所示。

 .. code-block:: c
    :caption: 单行注释范例
    :name: example_single_line_comment

    uint8_t lsb;            /* 低位字节 */
    uint8_t msb;            /* 高位字节 */

    lsb = my_data & 0xFFu; /* 获取my_data的低8位字节 */

    /* 获取my_data的高8位字节 */
    msb = (my_data >> 8u) & 0xFFu;
    
6. 注释的内容和 ``/*`` 及 ``*/`` 之间留各留一个空格。
7. 单独注释行的上方为空行。 
8. 定义或语句后的注释应该只对当前代码行做出注释，否则应使用单独注释行。
9. 如果一行写不下请使用多行注释。

多行注释
^^^^^^^^^

**要求：**

1. 注释的起始点与该处代码的缩进相对应。
2. 注释本身至少占用三行，且注释上方为空行。

 多行注释使用范例，如 :numref:`example_multi_line_comment` 所示。

 .. code-block:: c
    :caption: 多行注释范例
    :name: example_multi_line_comment

    int char_get (void)
    {
        /*
         * ... 注释内容 ...
         * ... 注释内容 ...
         */
         
        /* ... 语句块 ... */
    }

3. ``/*`` 和 ``*/`` 各自单独占用一行。
4. 每行注释内容前以 ``*`` 开始，且和上一行的 ``*`` 对齐。
5. 注释内容与开始的 ``*`` 相隔一个空格。


文件内分割线注释
-----------------

分割线注释仅用于对函数、定义进行视觉上的分割，便于阅读。

**要求：**

1. 起始点为第一行，结束点为第 ``80`` 行，中间全部用 ``*`` 。
2. 不能用于函数体内部。
3. 函数注释被放在头文件的非 ``static`` 函数在定义前放置一条分割线。

 分割线注释使用范例如 :numref:`example_split_line_comment` 所示。

 .. code-block:: c
    :caption: 分割线注释使用范例
    :name: example_split_line_comment

    /******************************************************************************/
    int foo (int a, int b, int c)
    {
        ... 
    }

    /******************************************************************************/
    int bar (int a, int b, int c)
    {
        ...
    }



文件内代码分组注释
-----------------------

为了阅读代码方便，建议按以下顺序对文件进行简单分组：头文件包含、宏定义、外部变量声明、外部函数声明、本地全局变量声明、本地函数声明、本地全局变量定义、本地函数定义和外部函数定义。

**要求：**

1. 注释起始点为行起始地点。
2. 注释的第一行没有结束符，除了第一个字符 ``/`` 其他的字符均为 ``*``
3. 第一行最后一个 ``*`` 出现在第 ``80`` 个字符的位置。
4. 第二行空 ``2`` 个空格后为简短的分组注释内容。
5. 最后一行的起始点为行起始地点。
6. 最后一行前 ``79`` 个字符为 ``*`` 。
7. 最后一行第 ``80`` 个字符为 ``/`` 。如 :numref:`example_group_comment` 所示。
8. 函数体外的块注释内容从第二行开始，与左边界的距离为两个空格。

 .. code-block:: c
    :caption: 分组注释
    :name: example_group_comment

    /***************************************************************************
      includes
    ***************************************************************************/


全局常量宏和全局变量注释
-------------------------

全局常量宏和全局变量应该全部要进行注释，尤其全局变量。

**要求：**

1. 使用 ``/**< \brief`` 开始注释，其中 ``\brief`` 可选，但建议使用。
2. 在宏或变量定义的后面编写注释。
3. 相似或功能相同的定义后的注释开始处对齐。
4. 若一行写不下，则在定义的上面一行使用单独行注释。
5. 单独行注释使用 ``/** \brief`` 开始。

常量宏和全局变量定义注释范例如 :numref:`example_constant_macro_and_global_comment` 所示。


 .. code-block:: c
    :caption: 常量宏和全局变量定义注释范例
    :name: example_constant_macro_and_global_comment

    #define AW_I2C_M_7BIT          0x0000u     /**< \brief 7位设备地址(默认) */
    #define AW_I2C_M_10BIT         0x0001u     /**< \brief 10位设备地址 */

    /** \brief 忽略所有无应答错误 (包括从机地址无应答和数据无应答) */
    #define AW_I2C_M_IGNORE_NAK   0x0020u

    int  g_i2c_ctlr_num;    /**< \brief I2C控制器个数 */


枚举和结构的注释
-----------------

枚举和结构的注释相同，现以结构体的定义为例说明。

**要求：**

1. 结构体定义必须有结构体本身的注释和结构体成员的注释。
如 :numref:`example_struct_comment` 所示为结构体定义范例。

 .. code-block:: c
    :caption: 结构体注释范例
    :name: example_struct_comment
    :linenos:
    :emphasize-lines: 10-12

    /**
     * \brief 环形缓冲区管理结构
     * 
     * 这是一个免锁的环形缓冲区，不需要记录缓冲中数据的个数。
     * 这个结构可以静态或动态创建，如果使用动态创建，则调用者必须负责内存管理。
     * 
     * \note 不要直接操作本结构的成员
     */
    struct aw_ring_buffer {
        int     in;     /**< \brief 缓冲区数据写入位置 */
        int     out;    /**< \brief 缓冲区数据读出位置 */
        int     size;   /**< \brief 缓冲区大小 */

        /** 
         * \brief 缓冲区指针
         * 
         * 这个指针指向的内存空间可以静态或动态创建，如果使用动态创建，
         * 则调用者必须负责内存管理。
         */
        char   *p_buf;
    };


2. 结构体的注释使用特殊注释块 ``/**`` 开始，至少使用一个 ``\brief`` 进行简短描述，其它的注释可视结构体复杂程序酌情注释。

3. 结构体成员后的注释（ ``10~12`` 行）使用特殊注释块 ``/**<``开始， ``\brief`` 是可选的，但建议使用，这样生成的文档阅读更方便。

4. 若结构体成员后的空间不够书写（如 ``14~20`` 行），可写在上方。注意此时使用注释块 ``/**`` ，而不是 ``/**<`` 。


全局带参数宏和函数体的注释
---------------------------

全局带参数宏和每个函数的开头都必须有注释，它们使用相同的注释规则，以函数注释为例，如 :numref:`example_function_header_comment` 所示。优先使用中文。

 .. code-block:: c
    :caption: 函数头的注释
    :name: example_function_header_comment

    /**
     * \brief 简短的作用描述
     * 
     * \details 详细描述（可选），如算法的介绍等
     *
     * \param[in]       输入参数  参数描述
     * \param[out]      输出参数  参数描述
     * \param[in,out]   双向参数  参数描述
     *
     * \retval 返回值1  返回值1描述
     * \retval 返回值2  返回值2描述
     *
     * \note 特殊说明，如注意事项，函数使用条件等
     */

其中 ``\brief`` 简短描述是强制的， ``\details`` 是可选的，建议如果函数比较复杂，或使用了某种算法，建议在 ``\details`` 中进行说明。其余的若有则写，没有则不写。

``\param`` 后面的方向指示如 ``[in]`` 等在不会造成误会的情况下可以省略。 ``\retval`` 可根据实际情况使用\return替代（如返回的是不确定的数据个数而不是错误码时）。

函数开头注释示例如 :numref:`example_function_header_comment2` 所示。示例函数的参数 ``p_msgs`` 用 ``[in,out]`` 表示双向参数，返回值是消息个数，无法罗列，使用 ``\return`` 进行说明，函数内部不对参数有效性进行检查，故使用 ``\note`` 特意说明。

 .. code-block:: c
    :caption: 函数头注释示例
    :name: example_function_header_comment2

    /**
     * \brief  开始一次I2C传输
     *
     * \param[in]      p_i2c   I2C控制块指针
     * \param[in,out]  p_msgs  I2C传输消息数组
     * \param[in]      num     I2C传输消息个数
     *
     * \return I2C传输完成的消息个数
     *
     * \note p_i2c指向的控制块和p_msgs指向的消息数组必须在调用本函数前初始化
     */
    int i2c_transfer (struct i2c_type *p_i2c, struct i2c_msg p_msgs[], size_t num);

如 :numref:`example_function_header_comment3` 所示为另一个注释示例，函数的参数的输入输出特性十分明显，故省略 ``[in]`` 、 ``[out]`` 等，且返回值只有3个，使用 ``\retval`` 进行罗列。

 .. code-block:: c
    :caption: 函数开头注释简化版示例
    :name: example_function_header_comment3

    /**
     * \brief 读I2C从机寄存器
     *
     * \param  p_dev I2C从机设备描述符
     * \param  reg   寄存器起始地址，从此地址开始读取数据，
     * \param  p_buf 数据缓冲区，读取的数据存放于此
     * \param  len   要读取的数据个数
     *
     * \retval AW_OK      读取成功
     * \retval -AW_EINVAL 参数错误，设备描述错误或buf为空指针时返回这个错误
     * \retval -AW_EIO    物理错误，物理设备不存在，或设备损坏不应答等
     */
    aw_err_t aw_i2c_read (aw_i2c_device_t  *p_dev,
                          uint32_t          reg,
                          uint8_t          *p_buf,
                          size_t            len);



